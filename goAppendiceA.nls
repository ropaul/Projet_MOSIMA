;; =================================================================
;; GO PROCEDURES
;; =================================================================


; fonction go, tout se fait ici (normalement)
to go
  ask persons[
    go_person 
  ]
  ask companies[
    go_company
  ]  
  ask matchings [
    go_matching
  ]
  
  go_links
  go_color
  go_globals
  
  tick
end

; action de chaques personnes 
to go_person
  if not haveJob [  ; si n'as pas de job faire 
   ask matching matchingAgentWhoNumber [
     if not member? ([who] of myself) seekP [ ; si le matchings ne te connait pas faire
       set seekP lput ([who] of myself) seekP  ; être ajouter au matchings
     ]  
   ]
   if ( not seekJob?)[ ; est ce qu'il ne cherche pas un job ?
      set seekP (remove-item [who] of myself seekP)
    ]
     set time_unemployed time_unemployed + 1; ADD 1 to the time of unemployement
  ]
end

; action pour chaque compagnies
to go_company
  ifelse not haveEmployee [ ; si n'a pas d'employé faire 
    ask matching matchingAgentWhoNumber [ ; si le matchings ne te connait pas faire
     if not member? ([who] of myself) seekC [
       set seekC lput ([who] of myself) seekC ; etre ajouter au matching
     ]
    ]
  ]
  [ ; sinon (le ifelse , ici c'est le else)
    let bad_productivity ((productivity skills ([skills] of employee)) < firing_quality_threshold) ; si l'employé n'est pas productif , le remercier
    let bad_luck (random-float 1 < unexpected_firing) ; si l'employé n'est pas chanceux , le remercier
    if (bad_productivity or bad_luck) [
      fire_employee(employee)
    ]
  ]
end

; action du matching
to go_matching
  set people_matched_this_turn 0
  set structural_unemployement 0
  set frictional_unemployement_rate 0
  set frictional_unemployement_time 0
  let n_treated (min (List (length seekP) (length seekC) M_value)) ; n_treated = la taille minimum entre seekP et seekC ;;;;;;;;;;;;;;;;; ICI QUE L'ON MODIFIE LE NOMBRE DE COUPLE DE MATCHING
  let unemployed_treated n-of n_treated (shuffle seekP)  ; shuffle : modifie aléatoirement la place des différents éléments dans le tableau seekP et prend n_treated du tableau seekP
  let recruitors_treated n-of n_treated (shuffle seekC) ; pareil avec seekC (pour plus de clareté , peut être le faire en 2 lignes)
  foreach (n-values n_treated [?])[  ; pour 1 a n_treated
    let a_person_number (item ? unemployed_treated) ;prende un numero d'agent PERSON sans emploie 
    let a_company_number (item ? recruitors_treated) ; pareil avec COMPANIES
    let a_person (person a_person_number) ;prende un agent PERSON sans emploie
    let a_company (company a_company_number) ; pareil 
    let simi_person (similarity_person_to_company a_person a_company) ; fonction pour calculer la similarité entre personne/compagnie pour personne
    let simi_company (similarity_company_to_person a_company a_person) ; fonction pour calculer la similarité entre compagnie/personne pour compagnie
    let close_enough ((abs (simi_person - simi_company)) <= exceptional_matching) ; regarde si les similarité sont proches
    let good_enough ( (simi_person + simi_company) / 2 >= matching_quality_threshold ) ; regarde si la moyenne des similarité sont assez haute pour etre satisfaisante
    ifelse (close_enough and good_enough) [ ; si les conditions sont bonnes , alors il y a matching
      ask a_company [hire_employee a_person] 
      set seekP (remove-item (position a_person_number seekP) seekP)
      set seekC (remove-item (position a_company_number seekC) seekC)
    ]
    [ ; sinon , il n'y a pas embouche et on augmente le structural_unemployement
      set structural_unemployement structural_unemployement + 1  ; UPDATE OF STRCUTURAL UNEMPLOYEMENT HERE  
    ]
  ]
end

; met a jour les liens , si on veut les voir au pas
to go_links
  if linksVisible [
    ask links [ set color white]
  ]
  if linksVIsible = false [
    ask links [ set color black]
  ]
end

; met a jour les couleurs, si on veut les voir ou pas (si couleur activé en cours de route, les couleurs ne se mettent pas automatiquement)
to go_color
  if colorVisible = false [
    ask companies [set color grey]
    ask persons [set color white]
  ]
end

; update des différentes variable de la simulation
to go_globals
  let working_force count persons with [haveJob]  ; compte le nombre de personne avec emploie
  set unemployment_level count persons with [not haveJob]  ;  compte le combre de personne sans emploie  
  set labor_force (working_force + unemployment_level) ; les nombre de personne avec un emploie et ceux sans emploie mais qui cherche un emploie
  if labor_force != 0[
    set unemployement_rate ( unemployment_level /   labor_force) ; calcul le unemployement_rate
    ]
  set vacant_jobs count companies with [not haveEmployee]
  if labor_force != 0 [
    set vacancy_rate (vacant_jobs / labor_force) ; calcul le vacancy_rate
    ] 
  if Person_Number != 0 [
    set participation_rate ( labor_force / Person_Number) ; calcul le particpation_rate
    ]
  set natural_unemployement ( frictional_unemployement_rate  + structural_unemployement) ; calcul le natural_unemplyement
  
  ifelse ticks < time_window [ ; un tableau avec les différente valeur de unemplyment_rate et vacancy_rate ?
    set unemployement_rate_list lput unemployement_rate unemployement_rate_list
    set vacancy_rate_list lput vacancy_rate vacancy_rate_list
  ]
  [ ; cette liste se vide peut a peut
   ; set unemployement_rate_list lput unemployement_rate but-first unemployement_rate_list
   ; set vacancy_rate_list lput vacancy_rate but-first  vacancy_rate_list
  ]
end




  

;; =================================================================
;; DYNAMICS PROCEDURES
;; =================================================================

; calcul la productivté d'un employé
to-report productivity [skills1 skills2]
  let basic_productivity (skillSimilarity skills1 skills2) ; calcul sa productivité de base
  let luck ((random-float (2 * max_productivity_fluctuation)) - max_productivity_fluctuation) ; variation selon la chance de l'employé
  report (basic_productivity + luck)
end

; comment virer son employé
to fire_employee [the_employee]
  set haveEmployee False 
  set employee nobody 
  set color grey   ; HERE CHANGE OF COLOR
  ask the_employee [ 
    set haveJob False
    set employer nobody
    set color white     ; HERE CHANGE OF COLOR
    ask my-links [die]  ; HERE TO DESTROY A LINK BETWEEN COMPAGY AND PERSON
    ]
end

; comment engager un emploié
to hire_employee [the_person]  
  set people_matched_this_turn (people_matched_this_turn + 1)
  set haveEmployee True
  set employee the_person
  if colorVisible [set color green]   ; HERE CHANGE OF COLOR
  ask the_person [    
    set haveJob True
    update_frictional_unemployment time_unemployed ; met à jour le frictional_unemployement 
    set time_unemployed 0 ; TO CALCUL THE FRICTIONAL UNEMPLOYEMENT
    if colorVisible [set color blue ] ; HERE CHANGE OF COLOR
    set employer myself
    create-link-with myself ; HERE TO CREATE A LINK BETWEEN COMPAGY AND PERSON
    ]  
end


;; =================================================================
;; SIMILARITY PROCEDURES
;; =================================================================


; calcul la similarité entre les skills
to-report skillSimilarity [skills1 skills2]
  let accu 0
  foreach (n-values n_skills [?]) [
   let skill_of_1 (array:item skills1 ?) 
   let skill_of_2 (array:item skills2 ?)
   if (skill_of_1 = skill_of_2) [
    set accu (accu + 1)  ; regarde si les skill demandé sont les même , si oui , +1
   ]
  ]  
  report (accu / n_skills)
end 

; calcul la similarité de distance (distance euclidienne)
to-report localisationSimilarity [x1 y1 x2 y2]
  let dist sqrt ((x1 - x2) ^ 2 + (y1 - y2) ^ 2)
  report 1. - dist / distMax
end

; calcul la similarité des salaire
to-report salarySimilarity [salary1 salary2]
  let diff (salary1 - salary2)
  let temp (1. + diff / salaryMax)
  report (temp / 2)
end

; calcul la similarité d'une personne pour une personne
to-report similarity_person_to_company[a_person a_company]
  let accu 0
  set accu (accu + skillSimilarity ([skills] of a_person) ([skills] of a_company))
  set accu (accu + localisationSimilarity ([xcor] of a_person) ([ycor] of a_person) ([xcor] of a_company) ([ycor] of a_company))
  set accu (accu + salarySimilarity ([salary] of a_person) ([salary] of a_company))
  let motivation (random-float unexpected_worker_motivation)
  report ( (accu + motivation) / (3 + unexpected_worker_motivation) )
end

; calcul la similarité pour une comagnie
to-report similarity_company_to_person[a_company a_person]
  let accu 0
  set accu (accu + skillSimilarity ([skills] of a_person) ([skills] of a_company))
  set accu (accu + localisationSimilarity ([xcor] of a_person) ([ycor] of a_person) ([xcor] of a_company) ([ycor] of a_company))
  set accu (accu + salarySimilarity ([salary] of a_company) ([salary] of a_person))
  let motivation (random-float unexpected_company_motivation)
  report ( (accu + motivation) / (3 + unexpected_company_motivation) )
end




;; =================================================================
;; STATISTICS FUNCTIONS
;; =================================================================

;met a jour le frictional_unemployment
to update_frictional_unemployment [time]
  set frictional_unemployement_time (frictional_unemployement_time + time)
  if people_matched_this_turn != 0 [
    set frictional_unemployement_rate (frictional_unemployement_time / people_matched_this_turn)
  ]
end



;; =================================================================
;; FUNCTION FOR APPENDICE A
;; =================================================================


; si la PERSONS cherche un job ou pas
to-report seekJob?
  let rand (random-float 1)
  ifelse (rand < ( 1 / (1 - s)))[ ; une chance de 1/(1 - s) de ne pas chercher de job à ce tour ci
      report false  ; non , on ne cherche pas de job
  ]
  [
    report true ; oui , on cherche un job
  ] 
end
  
to-report M_value
  go_globals
  set M vacancy_rate * ( e ^ ( s * Unemployement_rate / Vacancy_rate))
  report M
end







