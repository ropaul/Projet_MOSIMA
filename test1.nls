;__includes[""] ;Discomment it and press the "Check" button to get the "include" dropbar

; necessaire pour utiliser des tableaux
extensions [array table]

; nos trois type d'agent : les PERSONS , les COMPANIES et les MATCHINGS (un seul matching pour l'instant)
breed[persons person]
breed[companies company]
breed[matchings matching]



; attribut des persons (la position est récuperable par des fonction de netlogo)
persons-own[
  haveJob
  skills
  salary
  employer
  
  time_unemployed ;; to count the frictional_unemployement
]


; atribut des compagnies (la position est récuperable par des fonction de netlogo)
companies-own[
  haveEmployee
  skills
  salary
  employee
]

; les différents variables du problème
globals[
  ; Statistic variables :
  labor_force ; definie dans l'artcle
  unemployment_level ;; definie dans l'artcle
  unemployement_rate ; definie dans l'artcle
  vacant_jobs ; definie dans l'artcle
  vacancy_rate ; definie dans l'artcle
  participation_rate  ; definie dans l'artcle
  frictional_unemployement_time ; definie dans l'artcle
  frictional_unemployement_rate ; definie dans l'artcle
  people_matched_this_turn ; nombre de matching par tour
  structural_unemployement ; ; definie dans l'artcle
  natural_unemployement ; definie dans l'artcle
  count_unemployed_total ; definie dans l'artcle
  unemployement_rate_list ; liste des valeurs de unemployement_rate
  vacancy_rate_list  ; liste des valeurs de vacancy_rate
 
 time_window ; WHAT THE FUCK IS THAT ?
 ; Multiple simulations variables
  maxNumberPerson  
  minNumberPerson 
  stepNumberPerson
  rangeNumberPerson
  maxNumberCompanies
  minNumberCompanies
  stepNumberCompanies
  rangeNumberCompanies
  n_ticks_max
  epsilon ; seuil
  VacancyRateList_simulations
  UnemployedRateList_simulations
  
 salaryMean ;; SLIDER
 salaryMax
 salaryMaxFluctu ;; SLIDER
 n_skills ;; SLIDER
 n_match ;; SLIDER
 matching_quality_threshold ;; SLIDER
 exceptional_matching ;; SLIDER
 unexpected_company_motivation ;; SLIDER
 unexpected_worker_motivation ;; SLIDER
 unexpected_firing ;; SLIDER
 firing_quality_threshold ;; SLIDER
 max_productivity_fluctuation ;; SLIDER
 distMax
 matchingAgentWhoNumber
 
 Person_Number
 Compagny_Number
 ;Rseed ;; INPUT
]

matchings-own [
   seekC   ; ça sert ?
   seekP  ; même question
]

;; =================================================================
;; SETUP PROCEDURES
;; =================================================================
   
to setup
  clear-all  ; efface tout dans l'interface
  
  random-seed Rseed  ; seed pour rendre tout reproductible 
  setup_globals ; 
  setup_persons
  setup_companies
  setup_matching
  reset-ticks ; mettre les ticks à zero
end 

; initialise les agents PERSONS
to setup_persons  
  set-default-shape persons "person" ; donne une superbe aparence de personne à nos PERSONS
  create-persons Person_Number  ;; création des agents PERSON
  [ set color white ; ils sont blanc
    set size 1.5  ; ils sont grand
    setxy random-xcor random-ycor ; ils sont partout
    set haveJob False  ; il commencent sans travail
    set employer nobody  ; personne ne les emploie
    setup_skills ; ils sont des skill (initialisé)
    setup_salary  ; ils veulent un salaire
    set time_unemployed 0 ; temps  pas employé
  ]
end

; Initialise les agents COMPANIES
to setup_companies  
  set-default-shape  companies "house" ; donne une aparence de maison
  create-companies Compagny_Number 
  [ set color grey ; gris
    set size 1.5 ; grand pareil
    setxy random-xcor random-ycor ; disperse les entreprises
    set haveEmployee False ; pas d'employer pour le moment
    set employee nobody ; personne n'est leurs employé
    setup_skills ; ont besoins de certainens compétences
    setup_salary  ; offre un certains salaire
  ]
end

; initialise les agents MATCHINGS
to setup_matching
  set-default-shape  matchings "target"
  create-matchings 1
  [ set color orange
    set size 2.
    setxy 0 0
    set seekP []
    set seekC []
    set matchingAgentWhoNumber who
    ]
end




;; =================================================================
;; GO PROCEDURES
;; =================================================================


; fonction go, tout se fait ici (normalement)
to go
  ask persons[
    go_person 
  ]
  ask companies[
    go_company
  ]  
  ask matchings [
    go_matching
  ]
  
  go_links
  go_color
  go_globals
  
  tick
end

; action de chaques personnes 
to go_person
  if not haveJob [  ; si n'as pas de job faire 
   ask matching matchingAgentWhoNumber [
     if not member? ([who] of myself) seekP [ ; si le matchings ne te connait pas faire
       set seekP lput ([who] of myself) seekP  ; être ajouter au matchings
     ]  
   ]
     set time_unemployed time_unemployed + 1; ADD 1 to the time of unemployement
  ]
end

; action pour chaque compagnies
to go_company
  ifelse not haveEmployee [ ; si n'a pas d'employé faire 
    ask matching matchingAgentWhoNumber [ ; si le matchings ne te connait pas faire
     if not member? ([who] of myself) seekC [
       set seekC lput ([who] of myself) seekC ; etre ajouter au matching
     ]
    ]
  ]
  [ ; sinon (le ifelse , ici c'est le else)
    let bad_productivity ((productivity skills ([skills] of employee)) < firing_quality_threshold) ; si l'employé n'est pas productif , le remercier
    let bad_luck (random-float 1 < unexpected_firing) ; si l'employé n'est pas chanceux , le remercier
    if (bad_productivity or bad_luck) [
      fire_employee(employee)
    ]
  ]
end

; action du matching
to go_matching
  set people_matched_this_turn 0
  set structural_unemployement 0
  set frictional_unemployement_rate 0
  set frictional_unemployement_time 0
  let n_treated (min (List (length seekP) (length seekC) n_match)) ; n_treated = la taille minimum entre seekP et seekC
  let unemployed_treated n-of n_treated (shuffle seekP)  ; shuffle : modifie aléatoirement la place des différents éléments dans le tableau seekP et prend n_treated du tableau seekP
  let recruitors_treated n-of n_treated (shuffle seekC) ; pareil avec seekC (pour plus de clareté , peut être le faire en 2 lignes)
  foreach (n-values n_treated [?])[  ; pour 1 a n_treated
    let a_person_number (item ? unemployed_treated) ;prende un numero d'agent PERSON sans emploie 
    let a_company_number (item ? recruitors_treated) ; pareil avec COMPANIES
    let a_person (person a_person_number) ;prende un agent PERSON sans emploie
    let a_company (company a_company_number) ; pareil 
    let simi_person (similarity_person_to_company a_person a_company) ; fonction pour calculer la similarité entre personne/compagnie pour personne
    let simi_company (similarity_company_to_person a_company a_person) ; fonction pour calculer la similarité entre compagnie/personne pour compagnie
    let close_enough ((abs (simi_person - simi_company)) <= exceptional_matching) ; regarde si les similarité sont proches
    let good_enough ( (simi_person + simi_company) / 2 >= matching_quality_threshold ) ; regarde si la moyenne des similarité sont assez haute pour etre satisfaisante
    ifelse (close_enough and good_enough) [ ; si les conditions sont bonnes , alors il y a matching
      ask a_company [hire_employee a_person] 
      set seekP (remove-item (position a_person_number seekP) seekP)
      set seekC (remove-item (position a_company_number seekC) seekC)
    ]
    [ ; sinon , il n'y a pas embouche et on augmente le structural_unemployement
      set structural_unemployement structural_unemployement + 1  ; UPDATE OF STRCUTURAL UNEMPLOYEMENT HERE  
    ]
  ]
end

; met a jour les liens , si on veut les voir au pas
to go_links
  if linksVisible [
    ask links [ set color white]
  ]
  if linksVIsible = false [
    ask links [ set color black]
  ]
end

; met a jour les couleurs, si on veut les voir ou pas (si couleur activé en cours de route, les couleurs ne se mettent pas automatiquement)
to go_color
  if colorVisible = false [
    ask companies [set color grey]
    ask persons [set color white]
  ]
end

; update des différentes variable de la simulation
to go_globals
  let working_force count persons with [haveJob]  ; compte le nombre de personne avec emploie
  set unemployment_level count persons with [not haveJob]  ;  compte le combre de personne sans emploie  
  set labor_force (working_force + unemployment_level) ; les nombre de personne avec un emploie et ceux sans emploie mais qui cherche un emploie
  if labor_force != 0[
    set unemployement_rate ( unemployment_level /   labor_force) ; calcul le unemployement_rate
    ]
  set vacant_jobs count companies with [not haveEmployee]
  if labor_force != 0 [
    set vacancy_rate (vacant_jobs / labor_force) ; calcul le vacancy_rate
    ] 
  if Person_Number != 0 [
    set participation_rate ( labor_force / Person_Number) ; calcul le particpation_rate
    ]
  set natural_unemployement ( frictional_unemployement_rate  + structural_unemployement) ; calcul le natural_unemplyement
  
  ifelse ticks < time_window [ ; un tableau avec les différente valeur de unemplyment_rate et vacancy_rate ?
    set unemployement_rate_list lput unemployement_rate unemployement_rate_list
    set vacancy_rate_list lput vacancy_rate vacancy_rate_list
  ]
  [ ; cette liste se vide peut a peut
    set unemployement_rate_list lput unemployement_rate but-first unemployement_rate_list
    set vacancy_rate_list lput vacancy_rate but-first  vacancy_rate_list
  ]
end
     

;; =================================================================
;; DYNAMICS PROCEDURES
;; =================================================================

; calcul la productivté d'un employé
to-report productivity [skills1 skills2]
  let basic_productivity (skillSimilarity skills1 skills2) ; calcul sa productivité de base
  let luck ((random-float (2 * max_productivity_fluctuation)) - max_productivity_fluctuation) ; variation selon la chance de l'employé
  report (basic_productivity + luck)
end

; comment virer son employé
to fire_employee [the_employee]
  set haveEmployee False 
  set employee nobody 
  set color grey   ; HERE CHANGE OF COLOR
  ask the_employee [ 
    set haveJob False
    set employer nobody
    set color white     ; HERE CHANGE OF COLOR
    ask my-links [die]  ; HERE TO DESTROY A LINK BETWEEN COMPAGY AND PERSON
    ]
end

; comment engager un emploié
to hire_employee [the_person]  
  set people_matched_this_turn (people_matched_this_turn + 1)
  set haveEmployee True
  set employee the_person
  if colorVisible [set color green]   ; HERE CHANGE OF COLOR
  ask the_person [    
    set haveJob True
    update_frictional_unemployment time_unemployed ; met à jour le frictional_unemployement 
    set time_unemployed 0 ; TO CALCUL THE FRICTIONAL UNEMPLOYEMENT
    if colorVisible [set color blue ] ; HERE CHANGE OF COLOR
    set employer myself
    create-link-with myself ; HERE TO CREATE A LINK BETWEEN COMPAGY AND PERSON
    ]  
end


;; =================================================================
;; SIMILARITY PROCEDURES
;; =================================================================


; calcul la similarité entre les skills
to-report skillSimilarity [skills1 skills2]
  let accu 0
  foreach (n-values n_skills [?]) [
   let skill_of_1 (array:item skills1 ?) 
   let skill_of_2 (array:item skills2 ?)
   if (skill_of_1 = skill_of_2) [
    set accu (accu + 1)  ; regarde si les skill demandé sont les même , si oui , +1
   ]
  ]  
  report (accu / n_skills)
end 

; calcul la similarité de distance (distance euclidienne)
to-report localisationSimilarity [x1 y1 x2 y2]
  let dist sqrt ((x1 - x2) ^ 2 + (y1 - y2) ^ 2)
  report 1. - dist / distMax
end

; calcul la similarité des salaire
to-report salarySimilarity [salary1 salary2]
  let diff (salary1 - salary2)
  let temp (1. + diff / salaryMax)
  report (temp / 2)
end

; calcul la similarité d'une personne pour une personne
to-report similarity_person_to_company[a_person a_company]
  let accu 0
  set accu (accu + skillSimilarity ([skills] of a_person) ([skills] of a_company))
  set accu (accu + localisationSimilarity ([xcor] of a_person) ([ycor] of a_person) ([xcor] of a_company) ([ycor] of a_company))
  set accu (accu + salarySimilarity ([salary] of a_person) ([salary] of a_company))
  let motivation (random-float unexpected_worker_motivation)
  report ( (accu + motivation) / (3 + unexpected_worker_motivation) )
end

; calcul la similarité pour une comagnie
to-report similarity_company_to_person[a_company a_person]
  let accu 0
  set accu (accu + skillSimilarity ([skills] of a_person) ([skills] of a_company))
  set accu (accu + localisationSimilarity ([xcor] of a_person) ([ycor] of a_person) ([xcor] of a_company) ([ycor] of a_company))
  set accu (accu + salarySimilarity ([salary] of a_company) ([salary] of a_person))
  let motivation (random-float unexpected_company_motivation)
  report ( (accu + motivation) / (3 + unexpected_company_motivation) )
end


;; =================================================================
;; MISCELLAENOUS VARIABLES SETTINGS
;; =================================================================


; initialise les variable global de la simulation
to setup_globals 
  ;; let's get sliders' values
 set time_window time_window_;; SLIDER
 set salaryMean salaryMean_;; SLIDER  
 set salaryMaxFluctu salaryMaxFluctu_ ;; SLIDER
 set n_skills n_skills_;; SLIDER
 set n_match n_match_ ;; SLIDER
 set matching_quality_threshold matching_quality_threshold_ ;; SLIDER
 set exceptional_matching exceptional_matching_ ;; SLIDER
 set unexpected_company_motivation unexpected_company_motivation_ ;; SLIDER
 set unexpected_worker_motivation unexpected_worker_motivation_ ;; SLIDER
 set unexpected_firing  unexpected_firing_ ;; SLIDER
 set firing_quality_threshold firing_quality_threshold_ ;; SLIDER
 set max_productivity_fluctuation max_productivity_fluctuation_ ;; SLIDER 
 set Person_Number Person_Number_;; SLIDER
 set Compagny_Number Compagny_Number_;; SLIDER
 
 
  set salaryMax ( salaryMean + salaryMaxFluctu)
  set distMax (world-width * world-width +  world-height *  world-height )
  
  set labor_force (count persons with [not haveJob] + count persons with [haveJob])
  set unemployment_level count persons with [not haveJob] 
   if Person_Number != 0[set unemployement_rate (unemployment_level /   Person_Number)]
  set vacant_jobs count companies with[not haveEmployee]
  if labor_force != 0[set vacancy_rate (vacant_jobs / labor_force)] 
  if Person_Number != 0[set participation_rate ( labor_force / Person_Number)]
  set frictional_unemployement_time 0
  set frictional_unemployement_rate 0
  set structural_unemployement 0
  set natural_unemployement 0
  set count_unemployed_total 0
  set people_matched_this_turn 0
 
  set unemployement_rate_list []
  set vacancy_rate_list []
end


; initialise les skills (utilisable par les agents PERSONS et COMPANIES)
to setup_skills
  set skills array:from-list n-values n_skills [0]
  foreach (n-values n_skills [?]) [
    array:set skills ? (random 2) 
  ]
end

; initalise les salaire (utilisable par les agents PERSONS et COMPANIES)
to setup_salary
  let random_variation (random salaryMaxFluctu)
  set salary (salaryMean + random_variation)
end


;; =================================================================
;; STATISTICS FUNCTIONS
;; =================================================================

;met a jour le frictional_unemployment
to update_frictional_unemployment [time]
  set frictional_unemployement_time (frictional_unemployement_time + time)
  if people_matched_this_turn != 0 [
    set frictional_unemployement_rate (frictional_unemployement_time / people_matched_this_turn)
  ]
end







